需要掌握的内容：

- 数组

  - 一维数组

  - 二维数组

- 数组的排序算法（了解）

  - 排序算法

    - 冒泡

    - 选择

  - 查找算法

    - 二分法

  - 数组工具类

    



1、数组：

------

1、数组：
    1、Java语言中的数组是一种**引用数据类型**。不属于基本数据类型。数组的**父类是Object**。
    2、数组实际上是一个容器，可以同时容纳多个元素。（数组是一个**数据的集合**。）
    数组：字面意思是“一组数据”
    3、数组当中可以存储“**基本数据**类型”的数据，也可以存储“**引用数据**类型”的数据。
    4、数组因为是引用类型，所以数组对象是**堆内存**当中。（数组是存储在堆当中的）
    5、数组当中如果存储的是“java对象”的话，实际上存储的是对象的“**引用**（内存地址）”，数组中不能直接存储		java对象。
    6、数组一旦创建，在java中规定，长度不可变。（**数组长度不可变**）
    7、数组的分类：一维数组、二维数组、三维数组、多维数组...（一维数组较多，二维数组偶尔使用！）
    8、所有的数组对象都有**length属性(java自带的)**，用来获取数组中元素的个数。
    9、java中的数组要求**数组中元素的类型统一**。比如int类型数组只能存储int类型，Person类型数组只能存储		Person类型。
    10、数组在内存方面存储的时候，数组中的元素内存地址(存储的每一个元素都是有规则的挨着排列的)是连续		的。**内存地址连续**。
    这是数组存储元素的特点（特色）。数组实际上是一种简单的数据结构。
    11、所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。
    （**数组中首元素的内存地址作为整个数组对象的内存地址**）
    12、数组中每一个元素都是**有下标**的，下标**从0开始**，以1递增。**最后一个元素的下标是：length - 1**
    下标非常重要，因为我们对数组中元素进行“存取”的时候，都需要通过下标来进行。
    **13、数组这种数据结构的优点和缺点：**
        **优点：查询/查找/检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构。**
            **为什么检索效率高？**
                **第一：每一个元素的内存地址在空间存储上是连续的。**
                **第二：每一个元素类型相同，所以占用空间大小一样。**
                **第三：知道第一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以**
                **通过一个数学表达式就可以计算出某个下标上元素的内存地址。直接通过内存地址定位**
                **元素，所以数组的检索效率是最高的。**

​            **数组中存储100个元素，或者存储100万个元素，在元素查询/检索方面，效率是相同的，**
​            **因为数组中元素查找的时候不会一个一个找，是通过数学表达式计算出来的。（算出一个**
​            **内存地址，直接定位的。）**
​    **缺点：**
​        **第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候，**
​    **效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。**
​        **第二：数组不能存储大数据量，为什么？**
​            **因为很难在内存空间上找到一块特别大的连续的内存空间。**

​    **注意：对于数组中最后一个元素的增删，是没有效率影响的。**



2、一维数组：

​	1、声明/定义一个一维数组：
​    语法格式：
​        int[] array1;
​        double[] array2;
​        boolean[] array3;
​        String[] array4;
​        Object[] array5;
​	2、初始化一个一维数组：
​    	包括两种方式：静态初始化一维数组，动态初始化一维数组。
​    	静态初始化语法格式：
​        	int[] array = {100, 2100, 300, 55};

​		也可以这样写：

​		 printArray(new int[]{1,2,3});

​    	动态初始化语法格式：
​       	int[] array = new int[5]; // 这里的5表示数组的元素个数。
​                                    // 初始化一个5个长度的int类型数组，每个元素默认值0
​        	String[] names = new String[6]; // 初始化6个长度的String类型数组，每个元素默认值null。

​		什么时候采用静态初始化方式，什么时候使用动态初始化方式呢？
​			当你创建数组的时候，**确定**数组中存储哪些具体的元素时，采用**静态**初始化方式。
​			当你创建数组的时候，**不确定**将来数组中存储哪些数据，你可以采用**动态**初始化的方式，预先分配内存空			间。

​	3、一维数组的深入，数组中存储的类型为：引用数据类型

​		对于数组来说，实际上只能存储java对象的“内存地址”。数组中存储的每个元素是“引用”。

​	4、关于一维数组的扩容:

​		1、在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？

​			  数组满了，需要扩容。

​		2、java中对数组的扩容：

​			  先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。

​		3、java中的数组是怎么进行拷贝的呢？

​			 System.arraycopy(拷贝源，拷贝源下标，拷贝目标，拷贝目标下标，长度);（5个参数）

​		4、结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的						  拷贝。

​						  可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。						  提高效率。

​	5、关于main方法上面的“String[] args”：

​		1、谁负责调用main方法？		jvm

​				JVM调用main方法的时候，会自动传一个String数组过来。

​		2、JVM默认传递过来的这个数组对象的长度？		默认0

​		3、这个数组什么时候里面会有值呢？
​				 其实这个数组是留给用户的，用户可以在控制台上输入参数，这个参数自动会被转换为“String[] args”
​				 例如这样运行程序：java ArrayTest05 abc def xyz
​				 那么这个时候JVM会自动将“abc def xyz”通过空格的方式进行分离，分离完成之后，自动放到“String[] 				args”数组当中。
​				所以main方法上面的String[] args数组主要是用来接收用户输入参数的。
  		  	把abc def xyz 转换成字符串数组：{"abc","def","xyz"}



3、二维数组：

​	1、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。
​	2、三维数组是什么？
​    	三维数组是一个特殊的二维数组，特殊在这个二维数组中每一个元素是一个一维数组。
​    	实际的开发中使用最多的就是一维数组。二维数组也很少使用。三维数组几乎不用。
​	3、二维数组静态初始化：
​    	int[][] array = {{1,1,1},{2,3,4,5},{0,0,0,0},{2,3,4,5},{2,3,4,5},{2,3,4,5},{2,3,4,5}};

​		  也可以这样写：

​		printArray(new int[][]{{1,2,3,4},{4,5,6,76},{1,23,4}});

​	4、二维数组中元素的：读和改。

```java
	a[0][0]：表示第1个一维数组中的第1个元素。
	a[3][100]：表示第4个一维数组中的第101个元素。
​注意：对于a[3][100]来说，其中 a[3] 是一个整体。[100]是前面a[3]执行结束的结果然后再下标100.
```

------



2、数组的排序算法：

------

1、排序算法：

​	1、冒泡排序算法：
​		1.1、**每一次循环**结束之后，都要找出**最大的数据**，放到参与比较的这堆数据的**最右边**。（冒出最大的那个气			泡。）
​		1.2、核心：
​    		拿着左边的数字和右边的数字比对，当左边 > 右边的时候，交换位置。

​		1.3、算法实现：

```java
	for(int i = arr.length-1; i > 0; i--){
        for(int j = 0; j < i; j++){
            // 不管是否需要交换位置，总之是要比较一次的。
            if(arr[j] > arr[j+1]){
                // 交换位置。
                // arr[j] 和 arr[j+1] 交换
                int temp;
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                count2++;
            }
        }
    }
```
2、选择排序：
    2.1、每一次从**这堆**“参与比较的数据当中”找出**最小值**，
    		拿着这个最小值和“参与比较的**这堆最前面的元素”交换位置**。

​	2.2、关键点：选择排序中的关键在于，你怎么找出一堆数据中最小的。

​	2.3、选择排序比冒泡排序的**效率高**。

​			高在交换位置的**次数**上。
​			选择排序的**交换位置是有意义的**。

​	2.4、算法实现：

```java
for(int i = 0; i < arr.length - 1; i++){
            // i的值是0 1 2 3
            // i正好是“参加比较的这堆数据中”最左边那个元素的下标。
            //System.out.println(i);
            // i是一个参与比较的这堆数据中的起点下标。
            // 假设起点i下标位置上的元素是最小的。
            int min = i;
            for(int j = i+1; j < arr.length; j++){
                count++;
                //System.out.println("===>" + j);
                if(arr[j] < arr[min]){
                    min = j; //最小值的元素下标是j
                }
            }

        // 当i和min相等时，表示最初猜测是对的。
        // 当i和min不相等时，表示最初猜测是错的，有比这个元素更小的元素，
        // 需要拿着这个更小的元素和最左边的元素交换位置。
        if(min != i){
            // 表示存在更小的数据
            // arr[min] 最小的数据
            // arr[i] 最前面的数据
            int temp;
            temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
            count2++;
        }
}
```

2.查找算法

​	二分法：

​	2.1、10(下标0) 11 12 13 14 15 16 17 18 19 20(下标10)   arr数组。

​	通过二分法查找，找出10这个元素的下标：
​    (0 + 10) / 2 --> **中间元素**的下标： 5

​	拿着中间这个元素和**目标要查找的元素进行对比**：
​    中间元素是：arr[5] --> 15
​    15 < 18(被查找的元素)
​    被查找的元素18在目前中间元素15的右边。
​    所以开始元素的下标从0变成 5 + 1.

​	再重新计算一个中间元素的下标：
​    开始下标是：5 + 1
​    结束下标是：10
​    (6 + 10) / 2 --> 8

​	8下标对应的元素arr[8]是18
​    找到的中间元素正好和被找的的元素18相等，表示找到了：下标为8

​	2.2、二分法查找的终止条件：一直折半，直到中间的那个元素恰好是被查找的元素。

​	2.3、**二分法查找算法是基于排序的基础之上**。（没有排序的数据是无法查找的。）

​	2.4、算法实现：

```java
	// 开始下标
    int begin = 0;
    // 结束下标
    int end = arr.length - 1;
    // 开始元素的下标只要在结束元素下标的左边，就有机会继续循环。
    while(begin <= end) {
        // 中间元素下标
        int mid = (begin + end) / 2;
        if (arr[mid] == dest) {
            return mid;
        } else if (arr[mid] < dest) {
            // 目标在“中间”的右边
            // 开始元素下标需要发生变化（开始元素的下标需要重新赋值）
            begin = mid + 1; // 一直增
        } else {
            // arr[mid] > dest
            // 目标在“中间”的左边
            // 修改结束元素的下标
            end = mid - 1; // 一直减
        }
    }
    return -1;
```
3、SUN公司已经为我们程序员写好了一个数组工具类。

​		java.util.Arrays;

​	 所有方法都是**静态的**，直接用**类名调用**。

​		3.1、 排序
​		**Arrays.sort(arr)**;
​		3.2、二分法查找（建立在排序基础之上。）
​    	**int index = Arrays.binarySearch(arr, 5)**;