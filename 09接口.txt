需要掌握的内容：

- final关键字
- 抽象类（abstract）
-  接口（interface）
  - [ ] 接口的语法
  - [ ] 接口的作用

- 类型和类型之间的关系
- 抽象类和接口的区别
- java中的包机制：package和import
- 访问控制权限（private/public/protected/默认）





1、final关键字：

------

1.1、final修饰的**类无法被继承**。
1.2、final修饰的**方法无法被覆盖**。
1.3、final修饰的**局部变量**，**一旦赋值**，**不可再改变**。
1.4、final修饰的成员变量必须“显示的”初始化。
     final修饰的**成员变量必须手动初始化**。
1.5、final修饰的成员变量一般**和static联用** ――> **常量**
	常量：值不可再改变的变量。
	常量在java规范中要求所有的常量“大写”。
1.6、final修饰的引用类型，**该引用不可再重新指向其他的java对象**。
     但是fianl修饰的引用，该引用**指向的对象的属性是可以修改**的。

------



2、抽象类（abstract）:

------

2.1、什么是抽象类？
			类和类之间具有**共同特征**，将这些共同特征提取出来，形成的就是抽象类。
			**类本身是不存在**的，所以**抽象类**无法创建对象《**无法实例化**》。
2.2、抽象类的数据类型：
			抽象类也属于**引用数据类型**。
2.3、抽象类的定义：
			语法：
				[修饰符列表] abstract class 类名{
					类体;
				}	
2.4、抽象类是**无法实例化**的，**无法创建对象**的，所以抽象类是**用来被子类继承**的。
2.5、**final和abstract不能联合使用**，这两个关键字是对立的。
2.6、抽象类的**子类**可以是**抽象类**。也可以是**非抽象类**。
2.7、抽象类虽然无法实例化，但是**抽象类有构造方法**，这个构造方法是**供子类使用**的。
2.8、抽象类关联到一个概念：抽象方法。
	什么是抽象方法呢？
			抽象方法表示没有实现的方法，**没有方法体的方法**。例如：
				public abstract void doSome();
				抽象方法特点是：
					特点1：没有方法体，以分号结尾。
					特点2：前面修饰符列表中有abstract关键字。		
2.9、抽象类中不一定有抽象方法，**抽象方法必须出现在抽象类中**。
2.10、重要结论：重要结论五颗星*****（必须记住）
		**一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现了。**不然编译器就报错了。	
		这里的覆盖或者说重写，也可以叫做实现。（对抽象的实现。）
2.11、抽象类不能被final修饰。
	       抽象方法不能被final修饰。

（判断题）：java语言中凡是没有方法体的方法都是抽象方法。
		不对，错误的。
		Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
		都不是抽象方法，例如：
			public native int hashCode();
			这个方法底层调用了C++写的动态链接库程序。
			前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。

------



3、接口（interface）：

------

?	接口也是一种引用类型，可以等同看做类。

- 接口的语法：
		3.1、接口也是一种“**引用数据**类型”。**编译之后**也是**一个class字节码文件**。
		3.2、接口是**完全抽象**的。（**抽象类是半抽象**。）或者也可以说接口是特殊的抽象类。
		3.3、接口的定义和语法：
			[修饰符列表] interface 接口名{}
		3.4、接口**支持多继承**，一个接口可以继承多个接口。
		3.5、接口中只包含两部分内容，一部分是：**常量**。一部分是：**抽象方法**。接口中没有其它内容
		 		只有以上两部分。
		3.6、接口中所有的元素都是**public**修饰的。（都是公开的。）
		3.7、接口中的**抽象方法**定义时：**public abstract修饰符可以省略**。
		3.8、接口中的**常量**的**public static final可以省略**。
		3.9、接口中的方法都是抽象方法，所以接口中的**方法不能有方法体**。
		3.10、**类和类之间叫做继承，类和接口之间叫做实现**。
					**继承**使用**extends**关键字完成。
					**实现**使用**implements**关键字完成。
		3.11、五颗星（*****）：**当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现						（覆盖、重写）。**	
		3.12、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？	
					重点（五颗星*****）：**一个类可以同时实现多个接口**。
					类比：对于计算机来说，一个机箱上有多个接口，一个接口是接键盘的，
					一个接口是接鼠标的，一个接口是接电源的，一个接口是接显示器的.....
					这种机制弥补了java中的哪个缺陷？
							java中类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中
							存在多继承，java中的接口弥补了单继承带来的缺陷。	
        			**接口A和接口B**虽然**没有继承关系**，但是写代码的时候，**可以互转**。
        			编译器没意见。但是运行时可能出现：ClassCastException
					  需要加：**instanceof运算符进行判断**。	
					之前有一个结论：
						无论向上转型还是向下转型，两种类型之间必须要有继承关系，
						没有继承关系编译器会报错。（这句话不适用在接口方面。）
		3.13、继承和实现都存在的话，代码应该怎么写？
					**extends** 关键字在**前**。
					**implements** 关键字在**后**。
					例如：class Cat extends Animal implements Flyable{}
	
- 接口的作用：
	
	?	3.1、可以使项目**分层**，所有层都**面向接口开发**，**开发效率提高**了。
	
	?	3.2、接口使代码和代码之间的**耦合度降低**，就像内存条和主板的关系，变得“可插拔”。
?			 可以随意切换。
	
	?			接口和抽象类都能完成某个功能，**优先选择接口**。
	?			因为接口可以多实现，多继承。
	?			并且一个类除了实现接口之外，还可以去继承其他类（保留了类的继承）。
	
	?	3.3、总结一句话：三个字“解耦合”:
	?		面向接口编程，可以**降低程序的耦合度**，**提高程序的扩展力**。符合**OCP**开发原则。
?		接口的使用离不开多态机制。（**接口+多态才可以达到降低耦合度**。）
	
	?	3.4、接口可以解耦合，解开的是谁和谁的耦合！！！
	?		任何一个接口都有**调用者**和**实现者**。
	?		接口可以将调用者和实现者解耦合。
	?		调用者面向接口调用。
?		实现者面向接口编写实现。
	
	?		以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，
	?		模块和模块之间采用接口衔接。降低耦合度。

------



4、类型和类型之间的关系：

------

is a（继承）、has a（关联）、like a（实现）

?		is a：
?			Cat is a Animal（猫是一个动物）
?			**凡是能够满足is a的表示“继承关系”**
?			A extends B

?		has a：
?			I has a Pen（我有一支笔）
?			**凡是能够满足has a关系的表示“关联关系”**
?			关联关系**通常以“属性”的形式**存在。
?			A{
?				B b;
?			}
?		
?		like a:
?			Cooker like a FoodMenu（厨师像一个菜单一样）
?			**凡是能够满足like a关系的表示“实现关系”**
?			实现关系通常是：**类实现接口。**
?			A implements B

------



5、抽象类和接口的区别：

------

在**语法**上的区别：
	抽象类是半抽象的。
	接口是完全抽象的。

?	抽象类中有构造方法。
?	接口中没有构造方法。

?	接口和接口之间支持多继承。
?	类和类之间只能单继承。

?	一个类可以同时实现多个接口。
?	一个抽象类只能继承一个类（单继承）。

?	接口中只允许出现常量和抽象方法。

------



6、package和import

------

6.1、package：
	第一：package出现在java源文件**第一行**。
	第二：带有包名怎么编译？javac -d . xxx.java
	第三：怎么运行？java 完整类名:
	
	补充：以后说类名的时候，如果带着包名描述，表示完整类名。
	如果没有带包，描述的话，表示简类名。
		java.util.Scanner 完整类名。
		Scanner 简类名

6.2、import：
	import什么时候不需要？
		**java.lang不需要**。
		**同包下不需要**。 
		其它一律都需要。

?	怎么用？
?		import 完整类名;
?		import 包名.*;

?		import java.util.Scanner; // 完整类名。

?		这样是不是效率比较低？
?		这个效率不低，因为编译器在编译的时候，会自动把*变成具体的类名。
?		import java.util.*;
?		这是不允许的，因为在java语言中规定，这里的*只代表某些类的名字。
?		import java.*; 

------



7、访问控制权限：

------

7.1、访问控制权限都有哪些？
	4个。
	private	私有
	public 公开

?	protected	受保护
?	默认

7.2、以上的4个访问控制权限：控制的范围是什么？
	private 表示私有的，只能在**本类**中访问
	public 表示公开的，在**任何位置**都可以访问
	“默认”表示只能在**本类**，以及**同包**下访问。
	protected表示只能在**本类、同包、子类**中访问。

?	访问控制修饰符			本类			同包			子类			任意位置
---------------------------------------------------------------------------
?	public							可以			可以			可以			可以
?	protected					 可以			可以			可以			不行
?	默认							   可以			可以			不行			不行
?	private						  可以			不行			不行			不行

?	范围从大到小排序：public > protected > 默认 > private

------

7.3、访问控制权限修饰符可以修饰什么？
	属性（4个都能用）
	方法（4个都能用）
	类（public和默认能用，其它不行。）
	接口（public和默认能用，其它不行。）
	.....

------

